
  <!DOCTYPE html>
  <html lang="ko">
  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0, user-scalable=no" />
  <title>ì„±ê· ê´€ëŒ€ ê°ê·¤í•™ê³¼ ì…í•™ë¥  í…ŒìŠ¤íŠ¸ ğŸŠ</title>
  <style>
    :root{--orange:#ff9800;--dark:#0b0b0f}
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;background:var(--dark);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif;color:#fff}
    #container{
    position: relative;
    width: 100vw;
    height: 100vh;   /* fallback */
    height: 100svh;  /* modern browsers */
    touch-action: none;
    overscroll-behavior: none;
    }


    canvas#gameCanvas{position:absolute;left:0;top:0;width:100%;height:100%;display:block;z-index:1}
    /* Timer canvas */
    canvas#timerCanvas{position:absolute;right:3vw;top:3vh;width:12vw;height:12vw;max-width:72px;max-height:72px;z-index:30}
    /* Common UI layer */
    #ui{position:absolute;inset:0;z-index:40;pointer-events:none}
    #score{position:absolute;left:3vw;top:3vh;font-size:4.2vw;color:var(--orange);font-weight:700;z-index:41;pointer-events:none}
    /* Big centered messages (countdown, goal, etc.) */
    #bigMessage{position:absolute;left:50%;top:40%;transform:translate(-50%,-50%);font-size:18vw;font-weight:900;color:var(--orange);text-shadow:0 8px 30px rgba(0,0,0,0.7);z-index:60;display:none;pointer-events:none;text-align:center}
    #smallNotice{position:absolute;left:50%;top:55%;transform:translateX(-50%);font-size:4.6vw;color:#fff;z-index:60;display:none;pointer-events:none;text-align:center}
    #loading{position:absolute;left:50%;top:10%;transform:translateX(-50%);font-size:3.6vw;color:#fff;z-index:61}
    /* Intro screen */
    #intro{
      position:absolute;inset:0;background:rgba(0,0,0,0.35);backdrop-filter:blur(2px);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:70;pointer-events:auto;
    }
    #intro .card{width:86%;max-width:920px;padding:4vh 4vw;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.2));border-radius:18px;text-align:center}
    #intro h1{font-size:6.2vw;color:var(--orange);margin-bottom:1vh}
    #intro p{font-size:3.4vw;color:#fff8e6;margin-bottom:2.2vh;line-height:1.4}
    .btn{pointer-events:auto;background:var(--orange);color:#111;border:none;padding:1.2vh 4vw;border-radius:1.2vw;font-size:4.2vw;font-weight:700;cursor:pointer;box-shadow:0 10px 30px rgba(0,0,0,0.4)}
    .btn:active{transform:translateY(2px)}
    #resultScreen{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:80;pointer-events:auto}
    #resultScreen .card{width:86%;max-width:720px;padding:3vh 3vw;background:linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0.75));border-radius:14px;text-align:center}
    @media(min-width:800px){
      #intro h1{font-size:34px}
      #intro p{font-size:18px}
      .btn{font-size:16px}
      #bigMessage{font-size:200px}
      #score{font-size:20px}
    }
  </style>
  </head>
  <body>
  <div id="container">
    <!-- Game drawing canvas -->
    <canvas id="gameCanvas"></canvas>
    <!-- Timer UI -->
    <canvas id="timerCanvas" width="100" height="100"></canvas>

    <!-- UI layer -->
    <div id="ui">
      <div id="score">ì ìˆ˜: 0 | ì‹œê°„: 30</div>
      <div id="bigMessage">3</div>
      <div id="smallNotice"></div>
      <div id="loading">ë¡œë”© ì¤‘â€¦</div>

      <!-- Intro screen (background image applied via JS/canvas too) -->
      <div id="intro">
        <div class="card">
          <h1>ì„±ê· ê´€ëŒ€ ê°ê·¤í•™ê³¼ <br> ì…í•™ë¥  í…ŒìŠ¤íŠ¸ ğŸŠ</h1>
          <p>
            ğŸŠ ë–¨ì–´ì§€ëŠ” ê·¤ì„ ì¡ê³  í­íƒ„ì„ í”¼í•˜ì„¸ìš”!<br>
            ğŸŠ ì¼ë°˜ ê·¤ 1ì  Â· í™©ê¸ˆ ê·¤ 2ì  Â· í­íƒ„ì€ ì ìˆ˜ ë°˜ìœ¼ë¡œ ê°ì†Œ<br>
            ğŸ¯ 30ì´ˆ ê¸°ë³¸ ë¼ìš´ë“œ, 50ì  ì´ìƒì´ë©´ 10ì´ˆ ë³´ë„ˆìŠ¤ íƒ€ì„!<br>
            ê²°ê³¼ëŠ” ë¸Œë¼ìš°ì €(ë¡œì»¬)ì— ì €ì¥ë©ë‹ˆë‹¤.
          </p>
          <div style="display:flex;gap:12px;justify-content:center">
            <button id="startBtn" class="btn">ì‹œì‘í•˜ê¸°</button>
            <button id="shareBtn" class="btn">ê³µìœ í•˜ê¸°</button>
          </div>
        </div>
      </div>

      <!-- Result screen -->
      <div id="resultScreen">
        <div class="card">
          <h2 id="resultTitle">ê²°ê³¼ ë°œí‘œ</h2>
          <p id="resultText" style="
            font-size:3.6vw;      /* ê¸€ì”¨ í¬ê¸° ì¡°ê¸ˆ ì¤„ì„ */
            font-weight:800;       /* ê¸€ì”¨ ë‘ê»ê²Œ */
            line-height:1.3;       /* ì¤„ ê°„ê²© ì¡°ì ˆ */
            color:var(--orange);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); /* ê°€ë…ì„± ìœ„í•´ ê·¸ë¦¼ì ì¶”ê°€ */
            margin:2vh 0;
          "></p>
          <div style="display:flex;gap:10px;justify-content:center;margin-top:2vh">
            <button id="retryBtn" class="btn">ë‹¤ì‹œí•˜ê¸°</button>
            <button id="shareResultBtn" class="btn">ê²°ê³¼ ê³µìœ </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  /* =========================
    í†µí•© ê²Œì„ ìŠ¤í¬ë¦½íŠ¸
    - ì´ë¯¸ì§€ ëŠ” backchar/ í´ë”: mandarin.png, gold_mandarin.png, Bomb.png, char.png, SKKUpaper.jpg
    - ì‹¤í–‰: ë¡œì»¬ì„œë²„ ê¶Œì¥ (python -m http.server ë“±)
    ========================= */

  // ìº”ë²„ìŠ¤/ì»¨í…ìŠ¤íŠ¸
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const timerCanvas = document.getElementById('timerCanvas');
  const tctx = timerCanvas.getContext('2d');
  const loadingEl = document.getElementById('loading');
  const bigMessage = document.getElementById('bigMessage');
  const smallNotice = document.getElementById('smallNotice');
  const intro = document.getElementById('intro');
  const resultScreen = document.getElementById('resultScreen');
  const resultTitle = document.getElementById('resultTitle');
  const resultText = document.getElementById('resultText');
  const scoreEl = document.getElementById('score');
  const startBtn = document.getElementById('startBtn');
  const retryBtn = document.getElementById('retryBtn');
  const shareBtn = document.getElementById('shareBtn');
  const shareResultBtn = document.getElementById('shareResultBtn');

  let W = window.innerWidth, H = window.innerHeight;
  canvas.width = W; canvas.height = H;
  timerCanvas.style.width = Math.min(72, W*0.12)+'px';
  timerCanvas.style.height = Math.min(72, W*0.12)+'px';

  // ê²Œì„ ìƒíƒœ ë³€ìˆ˜
  let images = {};
  let loadedAll = false;
  let state = 'idle'; // idle, running, bonus_pending, bonus_countdown, bonus_running, result
  let items = []; // {x,y,sz,speed,type}
  let player = { 
    x: W/2, 
    y: H - H*0.18, 
    w: Math.max(120, Math.min(160, W*0.25)), // ìµœì†Œ 120, ìµœëŒ€ 160
    h: Math.max(120, Math.min(160, W*0.25))  // ìµœì†Œ 120, ìµœëŒ€ 160
  };
  let score = 0;
  let timeLeft = 30; // seconds (current round; bonus uses 10)
  let lastTs = 0;
  let spawnAcc = 0;
  let spawnInterval = 0.4; // avg seconds between spawns
  const MAX_ITEMS = 30;

  // ì´ë¯¸ì§€ preload (Promise.all)
  function preloadImages() {
    const src = {
      mandarin: 'backchar/mandarin.png',
      gold: 'backchar/gold_mandarin.png',
      bomb: 'backchar/Bomb.png',
      char: 'backchar/char.png',
      bg: 'backchar/SKKUpaper.jpg'
    };
    const keys = Object.keys(src);
    const promises = keys.map(k => new Promise(resolve=>{
      const img = new Image();
      img.onload = ()=>{ images[k]=img; resolve(); };
      img.onerror = ()=>{ console.warn('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:', src[k]); images[k]=null; resolve(); };
      img.src = src[k];
    }));
    return Promise.all(promises).then(()=>{ loadedAll = true; loadingEl.style.display='none'; });
  }

  // ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬
  function resize() {
    // ëª¨ë°”ì¼ì—ì„œ ì£¼ì†Œì°½ì„ ì œì™¸í•œ ì‹¤ì œ ë³´ì´ëŠ” ë†’ì´
    W = window.innerWidth;
    H = window.visualViewport ? window.visualViewport.height : window.innerHeight;

    canvas.width = W;
    canvas.height = H;

    // player í¬ê¸° ì¡°ì •: ìµœì†Œ 120, ìµœëŒ€ 160, í™”ë©´ ë¹„ìœ¨ ì ìš©
    player.w = Math.max(120, Math.min(160, W * 0.25));
    player.h = player.w;
    player.y = H - player.h - 10; // playerê°€ ì•„ë˜ì—ì„œ ì‚´ì§ ì—¬ìœ ìˆê²Œ ìœ„ì¹˜

    // íƒ€ì´ë¨¸ í¬ê¸°
    timerCanvas.style.width = Math.min(72, W * 0.12) + 'px';
    timerCanvas.style.height = Math.min(72, W * 0.12) + 'px';
}

// ì´ˆê¸° ì‹¤í–‰ ë° ì´ë²¤íŠ¸ ë“±ë¡
resize();
window.addEventListener('resize', resize);              // PC/ë¸Œë¼ìš°ì € í¬ê¸° ë³€ê²½
if(window.visualViewport){
  window.visualViewport.addEventListener('resize', resize); // ëª¨ë°”ì¼ ì£¼ì†Œì°½/íˆ´ë°” ëŒ€ì‘
}

  // ìœ í‹¸: í° ì¤‘ì•™ ë©”ì‹œì§€ (Promise ê¸°ë°˜)
  function showCenterMessage(text, ms=700){
    return new Promise(res=>{
      bigMessage.textContent = text;
      bigMessage.style.display = 'block';
      setTimeout(()=>{ bigMessage.style.display='none'; res(); }, ms);
    });
  }
  function showSmallNotice(text, ms=900){
    smallNotice.textContent = text; smallNotice.style.display='block';
    setTimeout(()=> smallNotice.style.display='none', ms);
  }

  // ìŠ¤í°
  function spawnOne() {
    if(items.length >= MAX_ITEMS) return;
    const r = Math.random();
    if(r < 0.6){
      items.push({ x: Math.random()*(W-52), y:-70, sz: Math.min(56, W*0.11), speed: 120 + Math.random()*40, type:'mandarin' });
    } else if(r < 0.8){
      items.push({ x: Math.random()*(W-56), y:-70, sz: Math.min(60, W*0.12), speed: 170 + Math.random()*60, type:'gold' });
    } else {
      items.push({ x: Math.random()*(W-52), y:-70, sz: Math.min(56, W*0.11), speed: 140 + Math.random()*50, type:'bomb' });
    }
  }

  // ì¶©ëŒ ê²€ì‚¬ (ì‚¬ê°í˜•)
  function collidesRect(a,b){
    return !(a.x + a.sz < b.x || a.x > b.x + b.w || a.y + a.sz < b.y || a.y > b.y + b.h);
  }

  // íƒ€ì´ë¨¸ ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸°: progress ì±„ìš°ê¸°(ì‹œê³„ë°©í–¥) + ì‹œì¹¨(ë°˜ì‹œê³„)
  function drawTimerCanvas(){
    const ctx = tctx;
    ctx.clearRect(0,0,100,100);
    const radius = 40;
    // progress ê¸°ì¤€: ê¸°ë³¸ ë¼ìš´ë“œ(30s)ì¼ ë•Œ (30 - timeLeft)/30
    const total = (state==='bonus_running')?10:30;
    const progress = Math.max(0, Math.min(1, (total - timeLeft) / total ));
    const startA = -Math.PI/2;
    const endA = startA + 2*Math.PI*progress;

    // background ring
    ctx.beginPath();
    ctx.arc(50,50,radius,0,2*Math.PI);
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 8;
    ctx.stroke();

    // filled arc (clockwise)
    ctx.beginPath();
    ctx.arc(50,50,radius,startA,endA,false);
    ctx.strokeStyle = 'orange';
    ctx.lineWidth = 8;
    ctx.stroke();

    // hand (counter-clockwise relative to progress)
    const handAngle = startA + 2*Math.PI*progress;
    ctx.beginPath();
    ctx.moveTo(50,50);
    ctx.lineTo(50 + Math.cos(handAngle)*(radius-6), 50 + Math.sin(handAngle)*(radius-6));
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();

    // seconds text
    ctx.font = 'bold 12px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`${Math.max(0,Math.ceil(timeLeft))}s`,50,50);
  }

  // ê²Œì„ ë£¨í”„ (rAF + delta time)
  function gameLoop(ts){
    if(!lastTs) lastTs = ts;
    const dt = (ts - lastTs)/1000; lastTs = ts;

    // Update only when running or bonus_running
    if(state === 'running' || state === 'bonus_running'){
      spawnAcc += dt;
      if(spawnAcc >= spawnInterval){
        const reps = Math.floor(spawnAcc / spawnInterval);
        for(let i=0;i<reps;i++) spawnOne();
        spawnAcc = spawnAcc % spawnInterval;
      }
      // update items
      for(let i=items.length-1;i>=0;i--){
        const it = items[i];
        it.y += it.speed * dt;
        // collision with player rect
        const pRect = { x: player.x, y: player.y, w: player.w, h: player.h };
        if(collidesRect({x:it.x,y:it.y,sz:it.sz}, pRect)){
          if(it.type === 'mandarin') score += 1;
          else if(it.type === 'gold') score += 2;
          else if(it.type === 'bomb') score = Math.max(0, Math.floor(score/2));
          items.splice(i,1);
          continue;
        }
        // remove if out of screen
        if(it.y > H + 120) items.splice(i,1);
      }
      // time decrement
      timeLeft -= dt;
      if(timeLeft <= 0){
        timeLeft = 0;
        // decide next state
        if(state === 'running'){
          if(score >= 50){
            // start bonus flow
            state = 'bonus_pending';
            // pause updates, kick off flow
            bonusFlow();
          } else {
            state = 'result';
            showResult();
          }
        } else if(state === 'bonus_running'){
          state = 'result';
          showResult();
        }
      }
    }

    // Render
    // background
    if(images.bg) ctx.drawImage(images.bg, 0, 0, W, H);
    else { ctx.fillStyle='#002'; ctx.fillRect(0,0,W,H); }

    // draw items
    for(const it of items){
      const img = it.type==='mandarin'?images.mandarin : (it.type==='gold'?images.gold:images.bomb);
      if(img) ctx.drawImage(img, it.x, it.y, it.sz, it.sz);
      else {
        ctx.fillStyle = it.type==='bomb'?'#222':'#ffa500';
        ctx.fillRect(it.x,it.y,it.sz,it.sz);
      }
    }

    // draw player centered at player.x
    if(images.char) ctx.drawImage(images.char, player.x, player.y, player.w, player.h);
    else { ctx.fillStyle='#fff'; ctx.fillRect(player.x, player.y, player.w, player.h); }

    // UI update
    scoreEl.textContent = `ì ìˆ˜: ${score} | ì‹œê°„: ${Math.max(0,Math.ceil(timeLeft))}${state==='bonus_running'?' (ë³´ë„ˆìŠ¤)':''}`;
    drawTimerCanvas();

    if(state !== 'result') requestAnimationFrame(gameLoop);
  }

  // ë³´ë„ˆìŠ¤ ì „í™˜ íë¦„: ëª©í‘œë‹¬ì„± -> clear items -> 3-2-1 -> ë³´ë„ˆìŠ¤ ì‹¤í–‰
  async function bonusFlow(){
    // show ëª©í‘œ ë‹¬ì„±
    await showCenterMessage('ëª©í‘œ ë‹¬ì„±!', 1000);
    // clear items
    items.length = 0;
    // short pause
    await new Promise(r=>setTimeout(r,300));
    // big 3-2-1
    await showCenterMessage('3',700);
    await showCenterMessage('2',700);
    await showCenterMessage('1',700);
    // small notice
    showSmallNotice('ë³´ë„ˆìŠ¤ íƒ€ì„ ì‹œì‘!', 900);
    // start bonus
    timeLeft = 10;
    state = 'bonus_running';
    lastTs = 0;
    requestAnimationFrame(gameLoop);
  }

  // ê²°ê³¼ í™”ë©´
  function showResult(){
    resultScreen.style.display = 'flex';
    const hist = JSON.parse(localStorage.getItem('gameScores')||'[]');
    hist.push(score);
    localStorage.setItem('gameScores', JSON.stringify(hist));
    const avg = hist.reduce((a,b)=>a+b,0)/hist.length;
    resultTitle.textContent = 'ê²°ê³¼ ë°œí‘œ ğŸ“';
    resultText.textContent = `ë‹¹ì‹ ì˜ ê°ê·¤í•™ê³¼ ì…í•™ë¥ ì€ ${Math.min(100, Math.round((score/50)*73*10)/10)}% ì…ë‹ˆë‹¤! (ëˆ„ì  ${hist.length}íšŒ í‰ê·  ${(Math.min(100, Math.round((avg/50)*73*10)/10))}%)`;
  }

  // show center message helper
  function showCenterMessage(text, ms=700){
    return new Promise(res=>{
      bigMessage.textContent = text;
      bigMessage.style.display = 'block';
      setTimeout(()=>{ bigMessage.style.display='none'; res(); }, ms);
    });
  }

  // input handling (mouse/touch) - player x control
  function setPlayerFromClientX(cx){
    player.x = Math.max(0, Math.min(W - player.w, cx - player.w/2));
  }
  window.addEventListener('mousemove', e => { if(state!=='idle') setPlayerFromClientX(e.clientX); });
  // í”Œë ˆì´ì–´ ì´ë™ + í™”ë©´ ìŠ¤í¬ë¡¤ ë°©ì§€
  window.addEventListener('touchmove', e => {
    e.preventDefault();  // ìŠ¤í¬ë¡¤ ë°©ì§€
    if(e.touches && e.touches[0]) setPlayerFromClientX(e.touches[0].clientX);
  }, {passive:false});

  // Start sequence (preload -> show intro -> start button)
  preloadImages().then(()=> {
    // hide loader, intro already visible
    loadingEl.style.display = 'none';
    // draw background into canvas for intro backdrop (keeps background while countdown)
    if(images.bg) ctx.drawImage(images.bg,0,0,W,H);
  });

  // Start button handler: big 3-2-1 with background maintained
  startBtn.addEventListener('click', async ()=>{
    // hide intro overlay but keep background visible in canvas
    intro.style.display = 'none';
    // ensure canvas shows background
    if(images.bg) ctx.drawImage(images.bg,0,0,W,H);
    // do 3-2-1 (centered messages) then run
    await showCenterMessage('3',700);
    await showCenterMessage('2',700);
    await showCenterMessage('1',700);
    // start running state
    score = 0; timeLeft = 30; items.length = 0; spawnAcc = 0; lastTs = 0;
    state = 'running';
    requestAnimationFrame(gameLoop);
  });

  // Retry
  retryBtn.addEventListener('click', ()=>{
    resultScreen.style.display = 'none';
    // reset and show countdown then start
    intro.style.display = 'none';
    showCenterMessage('3',700).then(()=>showCenterMessage('2',700)).then(()=>showCenterMessage('1',700)).then(()=>{
      score = 0; timeLeft = 30; items.length = 0; spawnAcc = 0; lastTs = 0; state='running'; requestAnimationFrame(gameLoop);
    });
  });

  // Sharing
  function shareCurrent(){
    const shareText = `ë‚˜ì˜ ê°ê·¤ ì ìˆ˜: ${score}ì ! ì„±ê· ê´€ëŒ€ ê°ê·¤í•™ê³¼ ì…í•™ë¥  í…ŒìŠ¤íŠ¸`;
    const url = window.location.href;
    if(navigator.share){
      navigator.share({title:'ê°ê·¤í•™ê³¼ ì…í•™ë¥  í…ŒìŠ¤íŠ¸', text: shareText, url}).catch(()=>prompt('ë§í¬ ë³µì‚¬:', url));
    } else {
      prompt('ë§í¬ ë³µì‚¬:', url);
    }
  }
  shareBtn.addEventListener('click', shareCurrent);
  if(shareResultBtn) shareResultBtn.addEventListener('click', shareCurrent);

  // resize init
  resize();
  </script>
  </body>
  </html>

